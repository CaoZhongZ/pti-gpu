#==============================================================
# Copyright (C) Intel Corporation
#
# SPDX-License-Identifier: MIT
# =============================================================

#!/usr/bin/env python3

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages as pdf

import os
import sys
import re
import subprocess
import argparse

def ParseArguments():
    argparser = argparse.ArgumentParser(description = "GPU Kernel Performance Hardware Metrics Analyzer")
    argparser.add_argument('-l', '--list', action = 'store_true', help = "list devices, metrics and kernels in the input performance metric data file")
    argparser.add_argument('-d', '--device', type = int, default = 0, help = "GPU device (device 0 by default)")
    argparser.add_argument('-k', '--kernel', help = "kernel name with shape, all kernels if this option is not specified")
    argparser.add_argument('-i', '--instance', type = int, default = 1, help = "kernel instance. all instances if < 1 (1 or the first instance by default)")
    argparser.add_argument('-m', '--metrics', help = "list of comma-separated metric names")
    argparser.add_argument('-o', '--output', help = "output file in text format if -l is present, PDF format regardless of file extension if -k is not present or if instance < 1")
    argparser.add_argument('-s', '--shaderdump', help = "shader dump folder for stall analysis")
    argparser.add_argument('-r', '--report', help = "stall analysis report, stdout by default")
    argparser.add_argument('-y', '--ylabel', help = "label for Y axis")
    argparser.add_argument('-x', '--xlabel', default = "Time", help = "label for X axis (defaut is \"Time\")")
    argparser.add_argument('-t', '--title', default = "Performance Metrics", help = "performance metric plot title")
    argparser.add_argument('input', help = 'hardware performance metric data file in .csv format generated by unitrace -k/--stall-sampling')

    return argparser.parse_args()

def Demangle(name):
    cxxfilt = ['c++filt']
    cxxfilt.append(name)

    p = subprocess.Popen(cxxfilt, stdin = subprocess.PIPE, stdout = subprocess.PIPE, text = True)
    stdout, _ = p.communicate()
    demangled = stdout.split("\n")[0]

    return demangled[18:]	#skip leading "typeinfo name for "

class BB:
    def __init__(self, bid, start, end, preds, succs):
        self.bid = bid
        self.start = start
        self.end = end
        self.preds = preds
        self.succs = succs

    def in_bb(self, ins):	# is ins in this basic block
        if ((ins >= self.start) and (ins <= self.end)):
            return True
        else:
            return False

    def get_bid(self): # get basic block id
        return self.bid

    def get_preds(self): # get predecessors
        return self.preds

    def get_head(self):	# get basic lock head instruction address
        return self.start

    def get_tail(self):	# get basic block tail instruction address
        return self.end


def ConstructCFG(instructions):
    bb_head = None
    in_bb = False
    bb_id = None
    preds = []
    succs = []
    bbs = dict()
    for addr, ins in enumerate(instructions):
        if ((re.match("// *B", ins) is not None) and ("Preds" in ins) and ("Succs" in ins)):
            if (in_bb):	# previous bb ends
                bb = BB(bb_id, bb_head, addr - 1, preds, succs)
                bbs[bb_id] = bb
            in_bb = True
            bb_head = addr
            bb_id = ins.split(" ")[1].split(":")[0].strip()
            preds = []
            for b in ins.split("Preds")[1].split("{")[1].split("}")[0].split(","):
                if (b.strip() != ""):
                    preds.append(b.strip())

            succs = []
            for b in ins.split("Succs")[1].split("{")[1].split("}")[0].split(","):
                if (b.strip() != ""):
                    succs.append(b.strip())

    # don't forget the last bb
    if (in_bb):
        bb = BB(bb_id, bb_head, len(instructions) - 1, preds, succs)
        bbs[bb_id] = bb

    if (len(bbs) == 0):	# at least one BB exits
        bb = BB("B000", 0, len(instructions) - 1, [], [])
        bbs["B000"] = bb	# dummy basic block id "B000"

    return bbs

def FindBB(bbs, ins):	# find BB of an instruction
    for bb_id, bb in bbs.items():
        if (bb.in_bb(ins)):
            return bb_id, bb

    return None, None	# never reaches here

def AnalyzeStalls(kernel, args, stalldf, report):
    shaders = os.listdir(args.shaderdump)
    files = []	# .asm files

    for f in shaders:
        if f.endswith(".asm"):
            files.append(args.shaderdump + "/" + f)

    asmfiles = []
    for f in files:
        with open(f, "r") as inf:
            for row in inf:
                if row.startswith("//.kernel"):
                    kname = row.split()[1]
                    kname = Demangle(kname)
                    if (kernel == kname):
                        asmfiles.append(f)

    if (len(asmfiles) == 0):
        print("Not found .asm file for " + kernel)
        return

    asm = asmfiles[0]
    if (len(asmfiles) > 1):	# kernel has been retried, found the latest one
        ctime = os.path.getctime(asm)
        for f in asmfiles:
            t = os.path.getctime(f)
            if (t > ctime):
                ctime = t
                asm = f

    ip = 0
    addressed = True
    with open(asm, "r") as inf:
        for row in inf:
            if ((row.startswith("//") == False) and ("//" in row)):
                if (row.startswith("/* [" + str('{:08X}'.format(ip)) + "] */ ") == False):	# no ip in asm
                    addressed = False
                if ("Compacted" in row):
                    ip = ip + 0x8
                else:
                    ip = ip + 0x10

    if (addressed == False):	# add ip addresses
        ip = 0
        with open(asm, "r") as inf:
            with open(asm + ".ip", "w") as outf:
                for row in inf:
                    if ((row.startswith("//") == False) and ("//" in row)):
                        outf.write("/* [" + str('{:08X}'.format(ip)) + "] */ " + row)
                        if ("Compacted" in row):
                            ip = ip + 0x8
                        else:
                            ip = ip + 0x10
                    else:
                        outf.write(row)

        asm = asm + ".ip"

    source_available = False
    instructions = []
    with open(asm, "r") as inf:
        for row in inf:
            ins = row.split("\n")
            if (len(ins) > 0):
                instructions.append(ins[0])
            else:
                instructions.append("")
            if (re.match("// *Line", row) is not None):
                source_available = True

    bbs = ConstructCFG(instructions)

    df = stalldf[["IP[Address]", "SbidStall[Events]"]]
    df = df[df["SbidStall[Events]"] > 0]	# drop 0s
    df = df.sort_values(by = ["SbidStall[Events]"], ascending = False)

    print("Kernel: " + kernel, file = report)
    print("Assembly with instruction addresses: " + asm, file = report)
    print("***********************************************************************************************", file = report)
    print("Sbid Stalls: ", file = report)

    for index, row in df.iterrows():
        ip = row["IP[Address]"]
        pc = int(ip, 16)
        for addr, ins in enumerate(instructions):
            if ((ins.startswith("//") == False) and ("//" in ins)):
                if (ins.startswith("/* [" + str('{:08X}'.format(pc))+ "] */ ") == True):	# found stalled instruction
                    words = ins.split("{")
                    sbids_stalled = []
                    if (len(words) >= 2):
                        for token in words[1].split("}")[0].split(","):
                            if (token.startswith("$") == True):
                                sbids_stalled.append(token)
                    if (len(sbids_stalled) == 0):
                        words = ins.split("(")	# check if SBID tokens are in (...)
                        if (len(words) >= 2):
                            i = 1
                            done = False
                            while (done == False):
                                for token in words[i].split(")")[0].split(","):
                                    if (token.startswith("$") == True):
                                        sbids_stalled.append(token)
                                        done = True
                                i = i + 1
                                if (i == len(words)):	# all words are inspected
                                    break

                    ins_stalled_not_line_resolved = addr
                    ins_stalled_not_file_resolved = addr
                    ins_stall_not_line_resolved = []
                    ins_stall_not_file_resolved = []
                    source_line_stalled = None
                    source_file_stalled = None
                    source_lines_stall = dict()
                    source_files_stall = dict()

                    bbid, bb = FindBB(bbs, addr)
                    bbs_to_check = [(bbid, bb.get_head(), addr - 1)]	# instrction at addr is the instruction stalled
                    j = 0
                    done = False
                    while (done == False):
                        if (len(bbs_to_check) <= j):
                            break
                        bid, start, end = bbs_to_check[j]
                        for addr2, ins2 in enumerate(reversed(instructions[start : end + 1])):
                            if (len(sbids_stalled) > 0):
                                if ((ins2.startswith("//") == False) and ("//" in ins2) and (re.match("/\* *\[", ins2) is not None)):
                                    tokens = ins2.split("{")
                                    if (len(tokens) > 1):
                                        sbids_stall = []
                                        for token in tokens[1].split("}")[0].split(","):
                                            if (token.startswith("$") == True):
                                                sbids_stall.append(token)
                                        for sbid in sbids_stalled:
                                            for sbid2 in sbids_stall:
                                                if (len(sbid.split(".")) > 1): # .dst or .src in bid
                                                    if (sbid2 == sbid.split(".")[0]):
                                                        sbids_stalled.remove(sbid)	# remove sbid from the sbids of the instruction stalled
                                                        ins_stall_not_line_resolved.append(end - addr2)	# source lines/files to be resolved
                                                        ins_stall_not_file_resolved.append(end - addr2)
                                                else:
                                                    if (sbid == sbid2.split(".")[0]): # stalled ins depends on ins2 or dependency already resolved
                                                        sbids_stalled.remove(sbid)	# remove sbid from the sbids of the instruction stalled
                                                        if ((sbid == sbid2) and ("sync." not in ins2)): # ins2 not a sync. ins depends on ins2
                                                            ins_stall_not_line_resolved.append(end - addr2) # source lines/files to be resolved
                                                            ins_stall_not_file_resolved.append(end - addr2)

                            if (re.match("// *Line", ins2) is not None):
                                if (ins_stalled_not_line_resolved != None): # source line of stalled instruction
                                    source_line_stalled = end - addr2
                                    ins_stalled_not_line_resolved = None

                                for i in ins_stall_not_line_resolved:
                                    source_lines_stall[i] = end - addr2
                                ins_stall_not_line_resolved.clear()

                            if (re.match("// *File", ins2) is not None):
                                if (ins_stalled_not_file_resolved != None): # source file of stalled instruction
                                    source_file_stalled = end - addr2
                                    ins_stalled_not_file_resolved = None

                                for i in ins_stall_not_file_resolved:
                                    source_files_stall[i] = end - addr2
                                ins_stall_not_file_resolved.clear()

                            if (len(sbids_stalled) == 0):
                                if (source_available == False):
                                    done = True
                                    break;
                                else:	# we are not done until source lines and files are resolved
                                        if ((ins_stalled_not_line_resolved == None) and (ins_stalled_not_file_resolved == None)):
                                            if ((len(ins_stall_not_line_resolved) == 0) and (len(ins_stall_not_file_resolved) == 0)):
                                                done = True
                                                break	# we are done

                        if (done == False):
                            for b in bbs[bid].get_preds():
                                bb = bbs[b]
                                bbs_to_check.append((b, bb.get_head(), bb.get_tail()))
                        else:
                            break

                        j = j + 1

                    print("\nInstruction", file = report)
                    print("  " + ins, file = report)
                    if (source_line_stalled != None):
                        print("  " + instructions[source_line_stalled][3:], file = report)
                        if (source_file_stalled != None):
                            print("  " + instructions[source_file_stalled][3:], file = report)

                    if ((len(source_lines_stall) > 0) or (len(ins_stall_not_line_resolved) > 0)):
                        print("is stalled potentially by", file = report)
                        for i, line in source_lines_stall.items():
                            print("  instruction", file = report)
                            print("    " + instructions[i], file = report)
                            print("    " + instructions[line][3:], file = report)
                            print("    " + instructions[source_files_stall[i]][3:], file = report)
                        for i in ins_stall_not_line_resolved:
                            print("  instruction", file = report)
                            print("    " + instructions[i], file = report)
                    else:
                        print("is stalled", file = report)

                    break


    # analyze stalls of other types

    type = ["ControlStall[Events]", "PipeStall[Events]", "SendStall[Events]", "DistStall[Events]", "SyncStall[Events]", "InstrFetchStall[Events]", "OtherStall[Events]"]
    for t in type:
        df = stalldf[["IP[Address]", t]]
        df = df[df[t] > 0]	# drop 0s
        if (df.shape[0] == 0):	# zero stalls. move to the next type
            continue
        df = df.sort_values(by = [t], ascending = False)

        print("***********************************************************************************************", file = report)
        print(t.split("Stall")[0] + " Stalls: ", file = report)

        for index, row in df.iterrows():
            ip = row["IP[Address]"]
            pc = int(ip, 16)
            for addr, ins in enumerate(instructions):
                if ((ins.startswith("//") == False) and ("//" in ins)):
                    if (ins.startswith("/* [" + str('{:08X}'.format(pc))+ "] */ ") == True):	# found stalled instruction
                        if (source_available == True):
                            ins_stalled_not_line_resolved = addr
                            ins_stalled_not_file_resolved = addr
                            source_line_stalled = None
                            source_file_stalled = None

                            for addr2, ins2 in enumerate(reversed(instructions[0: addr])):
                                if (re.match("// *Line", ins2) is not None):
                                    if (ins_stalled_not_line_resolved != None): # source line of stalled instruction
                                        source_line_stalled = addr - 1 - addr2
                                        ins_stalled_not_line_resolved = None

                                if (re.match("// *File", ins2) is not None):
                                    if (ins_stalled_not_file_resolved != None): # source file of stalled instruction
                                        source_file_stalled = addr - 1 - addr2
                                        ins_stalled_not_file_resolved = None

                                if ((ins_stalled_not_line_resolved == None) and (ins_stalled_not_file_resolved == None)):
                                    break	# we are done

                        print("\nInstruction", file = report)
                        print("  " + ins, file = report)
                        if (source_line_stalled != None):
                            print("  " + instructions[source_line_stalled][3:], file = report)
                            if (source_file_stalled != None):
                                print("  " + instructions[source_file_stalled][3:], file = report)

                        print("is stalled", file = report)

                        break

    print("===============================================================================================", file = report)

def AnalyzeStallMetrics(args, header, last):
    report_out = sys.stdout
    if (args.shaderdump is not None):
        if (os.path.isdir(args.shaderdump) == False):
            print("Shader dump folder " + args.shaderdump + " does not exist")
            return
        if (args.report is not None):
            report_out = open(args.report, "w")

    # only read lines from headerlinenumber to lastline
    df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)

    stalls = ["ControlStall[Events]", "PipeStall[Events]", "SendStall[Events]", "DistStall[Events]", "SbidStall[Events]", "SyncStall[Events]", "InstrFetchStall[Events]", "OtherStall[Events]"]

    if (args.kernel is None):
        # all kernels
        start = 0
        stop = -1
        kernel = ""
        p = None
        for index, row in df.iterrows():
            if (kernel == ""):
                kernel = row['Kernel']
                start = index
            else:
                if (kernel != row['Kernel']):
                    stop = index
                    df2 = df[start:stop]    # data frame of the kernel of interest
                    # remove rows with 0 stall events
                    df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
                    df3 = df2[stalls]

                    xlabels = []
                    xticks = []
                    for i, ip in enumerate(df2["IP[Address]"]):
                        xlabels.append(ip)
                        xticks.append(i)

                    df3 = df3.reset_index()
                    if (df3.shape[0] > 1):	# draw line chart if there are at least 2 data points
                        ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    else:	# draw bar chart otherwise
                        ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
                    plt.grid(visible = True, which = 'both', axis = 'y')
                    plt.legend(loc = 'best', fontsize = 4)
                    plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                    plt.tight_layout()
                    fig = ax.get_figure()
                    if (p == None):
                        p = pdf(args.output)
                    fig.savefig(p, format = 'pdf')
                    plt.close(fig)	# close figure to save memory

                    if (args.shaderdump is not None):
                        AnalyzeStalls(kernel, args, df2, report_out)

                    print("\nAnalyzed kernel " + kernel)

                    kernel = row['Kernel']
                    start = index

        # last kernel
        stop = df.shape[0]
        df2 = df[start : stop]    # data frame of the kernel of interest

        # remove rows with 0 stall events
        df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
        df3 = df2[stalls]

        xlabels = []
        xticks = []
        for i, ip in enumerate(df2["IP[Address]"]):
            xlabels.append(ip)
            xticks.append(i)

        df3 = df3.reset_index()
        if (df3.shape[0] > 1):
            ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
        else:
            ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)

        ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
        plt.grid(visible = True, which = 'both', axis = 'y')
        plt.legend(loc = 'best', fontsize = 4)
        plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
        plt.tight_layout()
        fig = ax.get_figure()
        if (p == None):
            p = pdf(args.output)
        fig.savefig(p, format = 'pdf')
        plt.close(fig)	# close figure to save memory

        if (args.shaderdump is not None):
            AnalyzeStalls(kernel, args, df2, report_out)

        print("\nAnalyzed kernel " + kernel)
        if (p != None):
            p.close()
            print("\nStall metric charts are stored in file " + args.output + " in PDF format")

        if ((args.shaderdump is not None) and (args.report is not None)):
            report_out.close()
            print("Stall report is in file " + args.report)

    else:
        counting = True
        start = -1
        stop = -1
        kernelfound = False

        for index, row in df.iterrows():
            if (row['Kernel'] == args.kernel):
                if (kernelfound == False):
                    start = index
                    kernelfound = True
            else:
                if (kernelfound == True):
                    stop = index
                    break

        if (kernelfound == False):
            print("No metric data for kernel " + args.kernel)
            return

        if (stop == -1):
            stop = df.shape[0]

        df2 = df[start : stop]    # data frame of the kernel of interest

        # remove rows with 0 stall events
        df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
        df3 = df2[stalls]

        xlabels = []
        xticks = []
        for i, ip in enumerate(df2["IP[Address]"]):
            xlabels.append(ip)
            xticks.append(i)

        df3 = df3.reset_index()
        if (df3.shape[0] > 1):
            ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
        else:
            ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
        ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
        plt.grid(visible = True, which = 'both', axis = 'y')
        plt.legend(loc = 'best', fontsize = 4)
        plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
        plt.tight_layout()
        plt.savefig(args.output)

        if (args.shaderdump is not None):
            AnalyzeStalls(args.kernel, args, df2, report_out)

        print("\nStall metric chart in file " + args.output + " has been successfully generated.")
        if ((args.shaderdump is not None) and (args.report is not None)):
            report_out.close()
            print("Stall report is in file " + args.report)

def PlotKernelInstancePerfMetrics(args, kernel, df, metrics):
    k = 0
    counting = True
    start = -1
    stop = -1
    instancefound = False

    for index, row in df.iterrows():
        if (pd.isna(row['Kernel']) == False):
            if ((row['Kernel'] == kernel) and (counting == True)):
                k = k + 1			# found kernel of interest
                counting = False		# set to false so this block will not enter again for this instance
                if (k == args.instance):	# found instance of interest
                    start = index
                    instancefound = True
        else:
            counting = True			# a new kernel and/or a new instance starts in the data frame
            if (instancefound == True):
                stop = index
                break

    if ((instancefound == True) and (stop == -1)):	# the instance of interest is at the end of data frame
        stop = df.shape[0]

    if (instancefound == False):
        print("No metric data for instance " + str(args.instance) + " of kernel " + kernel)
        return None

    df2 = df[start : stop]	# data frame of the instance of interest
    df3 = df2[metrics]

    if (df3.shape[0] > 1):
        ax = df3.plot(y = metrics, kind = 'line', xlabel = args.xlabel, ylabel = args.ylabel)
    else:
        ax = df3.plot(y = metrics, kind = 'bar', xlabel = args.xlabel, ylabel = args.ylabel)
    plt.grid(visible = True, which = 'both', axis = 'y')
    plt.legend(loc = 'best', fontsize = 4)
    plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
    plt.tight_layout()

    return ax

def AnalyzePerfMetrics(args, header, last):

    # only read lines from headerlinenumber to lastline
    df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)

    metrics = args.metrics.split(sep = ',')
    metrics_cleansed = []
    for metric in metrics:
        me = metric.strip()			# strip off leading and trailing whitespaces
        if (me not in df.columns):
            print("No metric data for " + metric)
            return
        else:
            metrics_cleansed.append(me)

    if (args.kernel is None):
        if (args.instance < 1):
            # all kernels and all instances
            start = 0
            stop = -1
            kernel = ""
            p = None
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == True):
                    stop = index	# current kernel instance ends

                    df2 = df[start : stop]	# data frame of the instance of interest
                    df3 = df2[metrics_cleansed]
                    if (df3.shape[0] > 1):
                        ax = df3.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = args.ylabel)
                    else:
                        ax = df3.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = args.ylabel)

                    plt.grid(visible = True, which = 'both', axis = 'y')
                    plt.legend(loc = 'best', fontsize = 4)
                    plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                    plt.tight_layout()
                    if (p == None):
                        p = pdf(args.output)
                    fig = ax.get_figure()
                    fig.savefig(p, format = 'pdf')
                    plt.close(fig)	# close figure to save memory
                    print("Analyzed kernel " + kernel)
                    kernel = ""	# reset kernel name to empty
                else:
                    if (kernel == ""):
                        start = index	# a new kernel instance starts
                        kernel = row['Kernel']

            if (p != None):
                p.close()
                print("Performance metric charts are successfully generated in PDF format")
            else:
                print("No performance metric data for any kernel")

        else:
            # specified instance of all kernels
            kernels = df['Kernel'].unique()
            p = None
            for kernel in kernels:
                if (pd.isna(kernel) == True):
                    continue

                ax = PlotKernelInstancePerfMetrics(args, kernel, df, metrics_cleansed)
                if (ax == None):
                    continue

                if (p == None):
                    p = pdf(args.output)
                fig = ax.get_figure()
                fig.savefig(p, format = 'pdf')
                plt.close(fig)	# close figure to save memory
                print("Analyzed kernel " + kernel)

            if (p != None):
                p.close()
                print("Performance metric charts are successfully generated in PDF format")
            else:
                print("No performance metric data for instance " + str(args.instance) + " for any kernel")
    else:
        if (args.instance < 1):
            # specified kernel all instances
            counting = True
            start = -1
            stop = -1
            p = None
            instance = 0
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == False):
                    if ((row['Kernel'] == args.kernel) and (counting == True)):
                        start = index			# found kernel of interest
                        counting = False		# set to false so this block will not enter again for this instance
                else:
                    if (counting == False):
                        # instance ends
                        stop = index
                        df2 = df[start : stop]	# data frame of the instance of interest
                        df3 = df2[metrics_cleansed]

                        if (df3.shape[0] > 1):
                            ax = df3.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = args.ylabel)
                        else:
                            ax = df3.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = args.ylabel)

                        plt.grid(visible = True, which = 'both', axis = 'y')
                        plt.legend(loc = 'best', fontsize = 4)
                        plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                        plt.tight_layout()
                        if (p == None):
                            p = pdf(args.output)
                        fig = ax.get_figure()
                        fig.savefig(p, format = 'pdf')
                        plt.close(fig)	# close figure to save memory
                        instance = instance + 1
                        print("Analyzed instance " + str(instance) + " of kernel " + args.kernel)

                        # continue scan for next instance
                        counting = True			# a new kernel and/or a new instance starts in the data frame
                        start = -1
                        stop = -1

            if ((start != -1) and (stop == -1)):	# the instance of interest is at the end of data frame
                stop = df.shape[0]

                df2 = df[start : stop]	# data frame of the instance of interest
                df3 = df2[metrics]

                if (df3.shape[0] > 1):
                    ax = df3.plot(y = metrics, kind = 'line', xlabel = args.xlabel, ylabel = args.ylabel)
                else:
                    ax = df3.plot(y = metrics, kind = 'bar', xlabel = args.xlabel, ylabel = args.ylabel)

                plt.grid(visible = True, which = 'both', axis = 'y')
                plt.legend(loc = 'best', fontsize = 4)
                plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                plt.tight_layout()
                if (p == None):
                    p = pdf(args.output)
                fig = ax.get_figure()
                fig.savefig(p, format = 'pdf')
                plt.close(fig)	# close figure to save memory
                instance = instance + 1
                print("Analyzed instance " + str(instance) + " of kernel " + args.kernel)

            if (p != None):
                p.close()
                print("Performance metric chart for kernel " + args.kernel + " is successfully generated in PDF format")
            else:
                print("No performance data for kernel " + args.kernel)

        else:
            # specified kernel specified instance
            ax = PlotKernelInstancePerfMetrics(args, args.kernel, df, metrics_cleansed)
            if (ax != None):
                plt.savefig(args.output)
                print("Performance metric chart for instance " + str(args.instance) + " of kernel " + args.kernel + " successfully generated")
            else:
                print("No performance data for instance " + str(args.instance) + " of kernel " + args.kernel)

def List(args):
    devices = []
    with open(args.input, "r") as f:
        linenum = 0
        counting = False
        for row in f:
            if (("=== Device" in row) and ("Metrics ===" in row)):
                words = row.split()
                for word in words:
                    if (word[0] == '#'):
                        device = word[1:]
                        devices.append(int(device))

    of = sys.stdout
    if (args.output is not None):
        of = open(args.output, "w")

    for device in devices:
        header = 0
        device_banner = "=== Device #" + str(device) + " Metrics ==="
        last = 0
        devicefound = False
        eustall = False
        with open(args.input, "r") as f:
            linenum = 0
            counting = False
            for row in f:
                if (("=== Device" in row) and ("Metrics ===" in row)):
                    if (device_banner in row):		# found device
                        counting = True
                        devicefound = True
                    else:
                        if (devicefound == True):	# done with the device of interest
                            break
                if (counting == True):
                    if (("OtherStall[Events]," in row) or (row.startswith("Kernel,"))):      # found header
                        header = linenum
                        counting = False
                        if ("OtherStall[Events]," in row):
                            eustall = True
                linenum += 1

            last = linenum

        print("Device " + str(device), file = of)
        # only read lines from headerlinenumber to lastline
        df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)
        print("    Metric", file = of)

        if (eustall == False):
            for m in df.columns.values.tolist():
                if (m == 'Kernel'):
                    continue
                print("        " + m, file = of)
                if (m == 'StreamMarker'):
                    break

            kernel_and_instances = dict()
            kernel = ""
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == True):
                    if kernel in kernel_and_instances:
                        kernel_and_instances[kernel] = kernel_and_instances[kernel] + 1
                    else:
                        if (kernel != ""):
                            kernel_and_instances[kernel] = 1

                    kernel = ""	# reset kernel name to empty
                else:
                    if (kernel == ""):
                        kernel = row['Kernel']

            print("    Kernel, Number of Instances", file = of)
            for i, (kernel, instances) in enumerate(kernel_and_instances.items()):
                print("        \"" + kernel + "\", " + str(instances), file = of)
        else:
            for m in df.columns.values.tolist():
                if (m == 'Kernel' or m == "IP[Address]"):
                    continue
                print("        " + m, file = of)
                if (m == 'OtherStall[Events]'):
                    break

            kernels = []
            for index, row in df.iterrows():
                kernel = row['Kernel']
                if (kernel not in kernels):
                    kernels.append(kernel)

            print("    Kernel", file = of)
            for kernel in kernels:
                print("        \"" + kernel + "\"", file = of)

    if (args.output is not None):
        of.close()

def main(args):
    if (os.path.isfile(args.input) == False):
        print("File " + args.input + " does not exist or cannot be opened")
        return

    if (os.stat(args.input).st_size ==0):
        print("File " + args.input + " is empty")
        return

    if (args.list == True):
        List(args)
        return

    if (args.output is None):
        print("Error: -o/--output is missing")
        return

    header = 0
    device_banner = "=== Device #" + str(args.device) + " Metrics ==="
    last = 0
    devicefound = False
    eustall = False
    with open(args.input, "r") as f:
        linenum = 0
        counting = False
        for row in f:
            if (("=== Device" in row) and ("Metrics ===" in row)):
                if (device_banner in row):		# found device
                    counting = True
                    devicefound = True
                else:
                    if (devicefound == True):	# done with the device of interest
                        break
            if (counting == True):
                if (("OtherStall[Events]," in row) or (row.startswith("Kernel,"))):      # found header
                    header = linenum
                    counting = False
                    if ("OtherStall[Events]," in row):
                        eustall = True
            linenum += 1

        last = linenum;

    if (devicefound == False):
        print("Device " + str(args.device) + " not found in input file")
        return

    if (eustall == False):
        if (args.metrics is None):
            print("-m option is missing")
            return
        if (args.ylabel is None):
            print("-y option is missing")
            return
        AnalyzePerfMetrics(args, header, last)
    else:
        AnalyzeStallMetrics(args, header, last)

if __name__== "__main__":
    main(ParseArguments())
